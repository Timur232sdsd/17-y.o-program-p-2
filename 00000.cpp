#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX = 1e9; // бесконечность
const int MAXN = 2000; // максимальный размер схемы
const int MAXK = 1024; // максимальное количество компонентов ЭВМ

int main() {
    int n, m; // размеры схемы
    cin >> n >> m;
    vector<vector<char>> scheme(n, vector<char>(m)); // схема ЭВМ
    vector<vector<int>> comp(n, vector<int>(m, -1)); // номера компонентов ЭВМ
    int x, y; // координаты источника синхросигнала
    int k = 0; // количество компонентов ЭВМ
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> scheme[i][j]; // считываем схему
            if (scheme[i][j] == 'X') { // находим источник
                x = i;
                y = j;
            }
            if (scheme[i][j] == 'I') { // находим выходы схем
                comp[i][j] = k++; // присваиваем номера компонентам
            }
        }
    }
    vector<vector<vector<int>>> f(n, vector<vector<int>>(m, vector<int>(MAXK, MAX))); // таблица динамического программирования
    f[x][y][0] = 0; // начальное значение
    for (int i = 0; i < n; i++) { // перебираем строки
        for (int j = 0; j < m; j++) { // перебираем столбцы
            for (int mask = 0; mask < (1 << k); mask++) { // перебираем битовые маски
                if (f[i][j][mask] == MAX) continue; // пропускаем недостижимые состояния
                if (scheme[i][j] == 'B' || scheme[i][j] == '.') { // если клетка пустая или занята компонентом
                    if (j + 1 < m) { // если можем перейти вправо
                        f[i][j + 1][mask] = min(f[i][j + 1][mask], f[i][j][mask]); // обновляем значение
                    }
                    if (i + 1 < n) { // если можем перейти вниз
                        f[i + 1][j][mask] = min(f[i + 1][j][mask], f[i][j][mask]); // обновляем значение
                    }
                }
                if (scheme[i][j] == 'X') { // если клетка является источником
                    if (j + 1 < m) { // если можем перейти вправо
                        f[i][j + 1][mask] = min(f[i][j + 1][mask], f[i][j][mask] + 1); // обновляем значение, добавляя длину провода
                    }
                    if (i + 1 < n) { // если можем перейти вниз
                        f[i + 1][j][mask] = min(f[i + 1][j][mask], f[i][j][mask] + 1); // обновляем значение, добавляя длину провода
                    }
                }
                if (scheme[i][j] == 'I') { // если клетка является выходом схемы
                    int t = comp[i][j]; // находим номер компонента
                    if (mask & (1 << t)) { // если компонент уже подключен
                        if (j + 1 < m) { // если можем перейти вправо
                            f[i][j + 1][mask] = min(f[i][j + 1][mask], f[i][j][mask]); // обновляем значение
                        }
                        if (i + 1 < n) { // если можем перейти вниз
                            f[i + 1][j][mask] = min(f[i + 1][j][mask], f[i][j][mask]); // обновляем значение
                        }
                    }
                    else { // если компонент еще не подключен
                        int new_mask = mask | (1 << t); // создаем новую битовую маску с подключенным компонентом
                        if (j + 1 < m) { // если можем перейти вправо
                            f[i][j + 1][new_mask] = min(f[i][j + 1][new_mask], f[i][j][mask] + 1); // обновляем значение, добавляя длину провода
                        }
                        if (i + 1 < n) { // если можем перейти вниз
                            f[i + 1][j][new_mask] = min(f[i + 1][j][new_mask], f[i][j][mask] + 1); // обновляем значение, добавляя длину провода
                        }
                    }
                }

}
        }
    }
    int ans = MAX; // ответ на задачу
    for (int mask = 0; mask < (1 << k); mask++) { // перебираем все битовые маски
        ans = min(ans, f[n - 1][m - 1][mask]); // находим минимальное значение функции в правом нижнем углу
    }
    if (ans == MAX) { // если ответ равен бесконечности
        cout << -1 << endl; // выводим -1
    }
    else { // иначе
        cout << ans << endl; // выводим ответ
    }
    return 0;
}